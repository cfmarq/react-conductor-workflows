{"version":3,"sources":["webpack://projectstorm/react-diagrams-routing/webpack/universalModuleDefinition","webpack://projectstorm/react-diagrams-routing/webpack/bootstrap","webpack://projectstorm/react-diagrams-routing/external \"@projectstorm/react-diagrams-defaults\"","webpack://projectstorm/react-diagrams-routing/external \"react\"","webpack://projectstorm/react-diagrams-routing/external \"lodash\"","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkFactory.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkModel.ts","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkWidget.tsx","webpack://projectstorm/react-diagrams-routing/./src/engine/PathFinding.ts","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkWidget.tsx","webpack://projectstorm/react-diagrams-routing/external \"@projectstorm/react-diagrams-core\"","webpack://projectstorm/react-diagrams-routing/external \"@projectstorm/geometry\"","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkFactory.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkModel.ts","webpack://projectstorm/react-diagrams-routing/./src/index.ts","webpack://projectstorm/react-diagrams-routing/external \"pathfinding\"","webpack://projectstorm/react-diagrams-routing/external \"paths-js/path\"","webpack://projectstorm/react-diagrams-routing/external \"@projectstorm/react-canvas-core\"","webpack://projectstorm/react-diagrams-routing/./src/dagre/DagreEngine.ts","webpack://projectstorm/react-diagrams-routing/external \"dagre\""],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","PathFindingLinkFactory","DefaultLinkFactory","super","NAME","ROUTING_SCALING_FACTOR","canvasMatrix","routingMatrix","hAdjustmentFactor","vAdjustmentFactor","calculateMatrixDimensions","allNodesCoords","_","values","this","engine","getModel","getNodes","map","item","x","getX","width","y","getY","height","allLinks","getLinks","allPortsCoords","flatMap","link","getSourcePort","getTargetPort","filter","port","allPointsCoords","getPoints","sumProps","props","reduce","acc","prop","canvas","getCanvas","concatedCoords","concat","minX","Math","floor","min","minBy","maxXElement","maxBy","maxX","max","offsetWidth","minYCoords","minY","maxYElement","maxY","offsetHeight","ceil","abs","markNodes","matrix","forEach","node","startX","endX","startY","endY","markMatrixPoint","translateRoutingX","translateRoutingY","markPorts","undefined","setDiagramEngine","getStateMachine","registerListener","stateChanged","event","newState","AbstractDisplacementState","deRegister","getActionEventBus","registerAction","Action","type","InputType","MOUSE_UP","fire","calculateRoutingMatrix","repaintCanvas","listener","canvasReady","defer","bank","setFactoryBank","deregister","PathFindingLinkWidget","diagramEngine","model","PathFindingLinkModel","length","calculateCanvasMatrix","canvasWidth","canvasHeight","matrixWidth","matrixHeight","range","Array","fill","cloneDeep","getCanvasMatrix","reverse","pathCoords","path","Path","moveto","slice","coords","lineto","print","DefaultLinkModel","options","React","Component","refPaths","state","selected","pathFinding","setRenderedPaths","ref","current","id","createRef","push","DefaultLinkSegmentWidget","getFactoryForLink","forwardRef","onSelection","setState","extras","points","paths","directPathCoords","calculateDirectPath","first","last","getRoutingMatrix","smartLink","calculateLinkStartEndCoords","start","end","pathToStart","pathToEnd","simplifiedPath","calculateDynamicPath","generateLink","generateDynamicPath","pathFinderInstance","PF","JumpPointFinder","heuristic","Heuristic","manhattan","diagonalMovement","DiagonalMovement","Never","instance","from","to","grid","Grid","findPath","startIndex","findIndex","point","endIndex","dynamicPath","Util","compressPath","RightAngleLinkWidget","handleMove","draggingEvent","dragging_index","handleUp","canDrag","removeEventListener","extraProps","index","coordinate","PointModel","position","Point","addPoint","_points","getPosition","getRelativeMousePoint","setPosition","remove","dx","dy","calculatePositions","setFirstAndLastPathsDirection","pointLeft","pointRight","hadToSwitch","setManuallyFirstAndLastPathsDirection","getFirstPathXdirection","getLastPathXdirection","j","LinkWidget","generateLinePath","getID","onMouseDown","button","addEventListener","onMouseEnter","lastHoverIndexOfPath","getOptions","testName","defaultProps","color","smooth","RightAngleLinkFactory","RightAngleLinkModel","_lastPathXdirection","_firstPathXdirection","pointModel","deserialize","fireEvent","g","dagre","graphlib","Graph","multigraph","setGraph","graph","setDefaultEdgeLabel","processedlinks","setNode","setEdge","v","getNode","w","layout","nodes","includeLinks","edges","e","edge","getLink","getFirstPoint","setPoints","getLastPoint"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"projectstorm/react-diagrams-routing\"] = factory();\n\telse\n\t\troot[\"projectstorm/react-diagrams-routing\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n","module.exports = require(\"@projectstorm/react-diagrams-defaults\");","module.exports = require(\"react\");","module.exports = require(\"lodash\");","import * as React from 'react';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { PathFindingLinkWidget } from './PathFindingLinkWidget';\nimport * as _ from 'lodash';\nimport * as Path from 'paths-js/path';\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\nimport {\n\tAbstractDisplacementState,\n\tAbstractFactory,\n\tAction,\n\tFactoryBank,\n\tInputType,\n\tListenerHandle\n} from '@projectstorm/react-canvas-core';\n\nexport class PathFindingLinkFactory extends DefaultLinkFactory<PathFindingLinkModel> {\n\tROUTING_SCALING_FACTOR: number = 5;\n\n\t// calculated only when smart routing is active\n\tcanvasMatrix: number[][] = [];\n\troutingMatrix: number[][] = [];\n\n\t// used when at least one element has negative coordinates\n\thAdjustmentFactor: number = 0;\n\tvAdjustmentFactor: number = 0;\n\n\tstatic NAME = 'pathfinding';\n\tlistener: ListenerHandle;\n\n\tconstructor() {\n\t\tsuper(PathFindingLinkFactory.NAME);\n\t}\n\n\tsetDiagramEngine(engine: DiagramEngine): void {\n\t\tsuper.setDiagramEngine(engine);\n\n\t\t// listen for drag changes\n\t\tengine.getStateMachine().registerListener({\n\t\t\tstateChanged: (event) => {\n\t\t\t\tif (event.newState instanceof AbstractDisplacementState) {\n\t\t\t\t\tconst deRegister = engine.getActionEventBus().registerAction(\n\t\t\t\t\t\tnew Action<DiagramEngine>({\n\t\t\t\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\t\t\t\tfire: () => {\n\t\t\t\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t\t\t\t\tdeRegister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.listener = engine.registerListener({\n\t\t\tcanvasReady: () => {\n\t\t\t\t_.defer(() => {\n\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tsetFactoryBank(bank: FactoryBank<AbstractFactory>): void {\n\t\tsuper.setFactoryBank(bank);\n\t\tif (!bank && this.listener) {\n\t\t\tthis.listener.deregister();\n\t\t}\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <PathFindingLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\n\t}\n\n\tgenerateModel(event): PathFindingLinkModel {\n\t\treturn new PathFindingLinkModel();\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all walkable points are marked by zeros.\n\t * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n\t */\n\tgetCanvasMatrix(): number[][] {\n\t\tif (this.canvasMatrix.length === 0) {\n\t\t\tthis.calculateCanvasMatrix();\n\t\t}\n\n\t\treturn this.canvasMatrix;\n\t}\n\tcalculateCanvasMatrix() {\n\t\tconst {\n\t\t\twidth: canvasWidth,\n\t\t\thAdjustmentFactor,\n\t\t\theight: canvasHeight,\n\t\t\tvAdjustmentFactor\n\t\t} = this.calculateMatrixDimensions();\n\n\t\tthis.hAdjustmentFactor = hAdjustmentFactor;\n\t\tthis.vAdjustmentFactor = vAdjustmentFactor;\n\n\t\tconst matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n\t\tconst matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n\n\t\tthis.canvasMatrix = _.range(0, matrixHeight).map(() => {\n\t\t\treturn new Array(matrixWidth).fill(0);\n\t\t});\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 1 1 0 0 0 0 |\n\t * | 0 0 1 1 0 0 1 1 |\n\t * | 0 0 0 0 0 0 1 1 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all points blocked by a node (and its ports) are\n\t * marked as 1; points were there is nothing (ie, free) receive 0.\n\t */\n\tgetRoutingMatrix(): number[][] {\n\t\tif (this.routingMatrix.length === 0) {\n\t\t\tthis.calculateRoutingMatrix();\n\t\t}\n\n\t\treturn this.routingMatrix;\n\t}\n\tcalculateRoutingMatrix(): void {\n\t\tconst matrix = _.cloneDeep(this.getCanvasMatrix());\n\n\t\t// nodes need to be marked as blocked points\n\t\tthis.markNodes(matrix);\n\t\t// same thing for ports\n\t\tthis.markPorts(matrix);\n\n\t\tthis.routingMatrix = matrix;\n\t}\n\n\t/**\n\t * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n\t * We use the functions below to translate back and forth between these coordinates, relying on the\n\t * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n\t */\n\ttranslateRoutingX(x: number, reverse: boolean = false) {\n\t\treturn x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\ttranslateRoutingY(y: number, reverse: boolean = false) {\n\t\treturn y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\n\t/**\n\t * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n\t * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n\t */\n\tcalculateMatrixDimensions = (): {\n\t\twidth: number;\n\t\thAdjustmentFactor: number;\n\t\theight: number;\n\t\tvAdjustmentFactor: number;\n\t} => {\n\t\tconst allNodesCoords = _.values(this.engine.getModel().getNodes()).map((item) => ({\n\t\t\tx: item.getX(),\n\t\t\twidth: item.width,\n\t\t\ty: item.getY(),\n\t\t\theight: item.height\n\t\t}));\n\n\t\tconst allLinks = _.values(this.engine.getModel().getLinks());\n\t\tconst allPortsCoords = _.flatMap(allLinks.map((link) => [link.getSourcePort(), link.getTargetPort()]))\n\t\t\t.filter((port) => port !== null)\n\t\t\t.map((item) => ({\n\t\t\t\tx: item.getX(),\n\t\t\t\twidth: item.width,\n\t\t\t\ty: item.getY(),\n\t\t\t\theight: item.height\n\t\t\t}));\n\t\tconst allPointsCoords = _.flatMap(allLinks.map((link) => link.getPoints())).map((item) => ({\n\t\t\t// points don't have width/height, so let's just use 0\n\t\t\tx: item.getX(),\n\t\t\twidth: 0,\n\t\t\ty: item.getY(),\n\t\t\theight: 0\n\t\t}));\n\n\t\tconst sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n\n\t\tconst canvas = this.engine.getCanvas() as HTMLDivElement;\n\t\tconst concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n\t\tconst minX =\n\t\t\tMath.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\n\t\t\tthis.ROUTING_SCALING_FACTOR;\n\t\tconst maxXElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['x', 'width']));\n\t\tconst maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n\t\tconst minYCoords = _.minBy(concatedCoords, 'y');\n\t\tconst minY =\n\t\t\tMath.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\t\tconst maxYElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['y', 'height']));\n\t\tconst maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n\n\t\treturn {\n\t\t\twidth: Math.ceil(Math.abs(minX) + maxX),\n\t\t\thAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n\t\t\theight: Math.ceil(Math.abs(minY) + maxY),\n\t\t\tvAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n\t\t};\n\t};\n\n\t/**\n\t * Updates (by reference) where nodes will be drawn on the matrix passed in.\n\t */\n\tmarkNodes = (matrix: number[][]): void => {\n\t\t_.values(this.engine.getModel().getNodes()).forEach((node) => {\n\t\t\tconst startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Updates (by reference) where ports will be drawn on the matrix passed in.\n\t */\n\tmarkPorts = (matrix: number[][]): void => {\n\t\tconst allElements = _.flatMap(\n\t\t\t_.values(this.engine.getModel().getLinks()).map((link) => [].concat(link.getSourcePort(), link.getTargetPort()))\n\t\t);\n\t\tallElements\n\t\t\t.filter((port) => port !== null)\n\t\t\t.forEach((port) => {\n\t\t\t\tconst startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t};\n\n\tmarkMatrixPoint = (matrix: number[][], x: number, y: number) => {\n\t\tif (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n\t\t\tmatrix[y][x] = 1;\n\t\t}\n\t};\n\n\tgenerateDynamicPath(pathCoords: number[][]) {\n\t\tlet path = Path();\n\t\tpath = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n\t\tpathCoords.slice(1).forEach((coords) => {\n\t\t\tpath = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n\t\t});\n\t\treturn path.print();\n\t}\n}\n","import { PathFindingLinkFactory } from './PathFindingLinkFactory';\nimport { DefaultLinkModel, DefaultLinkModelOptions } from '@projectstorm/react-diagrams-defaults';\n\nexport class PathFindingLinkModel extends DefaultLinkModel {\n\tconstructor(options: DefaultLinkModelOptions = {}) {\n\t\tsuper({\n\t\t\ttype: PathFindingLinkFactory.NAME,\n\t\t\t...options\n\t\t});\n\t}\n\n\tperformanceTune() {\n\t\treturn false;\n\t}\n}\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport PathFinding from '../engine/PathFinding';\nimport { PathFindingLinkFactory } from './PathFindingLinkFactory';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\n\nexport interface PathFindingLinkWidgetProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: PathFindingLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: PathFindingLinkFactory;\n}\n\nexport interface PathFindingLinkWidgetState {\n\tselected: boolean;\n}\n\nexport class PathFindingLinkWidget extends React.Component<PathFindingLinkWidgetProps, PathFindingLinkWidgetState> {\n\trefPaths: React.RefObject<SVGPathElement>[];\n\tpathFinding: PathFinding;\n\n\tconstructor(props: PathFindingLinkWidgetProps) {\n\t\tsuper(props);\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\t\tthis.pathFinding = new PathFinding(this.props.factory);\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={{}}\n\t\t\t/>\n\t\t);\n\t}\n\n\trender() {\n\t\tthis.refPaths = [];\n\t\t//ensure id is present for all points on the path\n\t\tvar points = this.props.link.getPoints();\n\t\tvar paths = [];\n\n\t\t// first step: calculate a direct path between the points being linked\n\t\tconst directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n\n\t\tconst routingMatrix = this.props.factory.getRoutingMatrix();\n\t\t// now we need to extract, from the routing matrix, the very first walkable points\n\t\t// so they can be used as origin and destination of the link to be created\n\t\tconst smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\t\tif (smartLink) {\n\t\t\tconst { start, end, pathToStart, pathToEnd } = smartLink;\n\n\t\t\t// second step: calculate a path avoiding hitting other elements\n\t\t\tconst simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n\n\t\t\tpaths.push(\n\t\t\t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n\t\t\t\tthis.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0')\n\t\t\t);\n\t\t}\n\t\treturn <>{paths}</>;\n\t}\n}\n","import * as PF from 'pathfinding';\nimport { PathFindingLinkFactory } from '../link/PathFindingLinkFactory';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\n\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\n\nconst pathFinderInstance = new PF.JumpPointFinder({\n\theuristic: PF.Heuristic.manhattan,\n\tdiagonalMovement: PF.DiagonalMovement.Never\n});\n\nexport default class PathFinding {\n\tinstance: any;\n\tfactory: PathFindingLinkFactory;\n\n\tconstructor(factory: PathFindingLinkFactory) {\n\t\tthis.instance = pathFinderInstance;\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Taking as argument a fully unblocked walking matrix, this method\n\t * finds a direct path from point A to B.\n\t */\n\tcalculateDirectPath(from: PointModel, to: PointModel): number[][] {\n\t\tconst matrix = this.factory.getCanvasMatrix();\n\t\tconst grid = new PF.Grid(matrix);\n\n\t\treturn pathFinderInstance.findPath(\n\t\t\tthis.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tgrid\n\t\t);\n\t}\n\n\t/**\n\t * Using @link{#calculateDirectPath}'s result as input, we here\n\t * determine the first walkable point found in the matrix that includes\n\t * blocked paths.\n\t */\n\tcalculateLinkStartEndCoords(\n\t\tmatrix: number[][],\n\t\tpath: number[][]\n\t): {\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tpathToStart: number[][];\n\t\tpathToEnd: number[][];\n\t} {\n\t\tconst startIndex = path.findIndex((point) => {\n\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\telse return false;\n\t\t});\n\t\tconst endIndex =\n\t\t\tpath.length -\n\t\t\t1 -\n\t\t\tpath\n\t\t\t\t.slice()\n\t\t\t\t.reverse()\n\t\t\t\t.findIndex((point) => {\n\t\t\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\t\t\telse return false;\n\t\t\t\t});\n\n\t\t// are we trying to create a path exclusively through blocked areas?\n\t\t// if so, let's fallback to the linear routing\n\t\tif (startIndex === -1 || endIndex === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst pathToStart = path.slice(0, startIndex);\n\t\tconst pathToEnd = path.slice(endIndex);\n\n\t\treturn {\n\t\t\tstart: {\n\t\t\t\tx: path[startIndex][0],\n\t\t\t\ty: path[startIndex][1]\n\t\t\t},\n\t\t\tend: {\n\t\t\t\tx: path[endIndex][0],\n\t\t\t\ty: path[endIndex][1]\n\t\t\t},\n\t\t\tpathToStart,\n\t\t\tpathToEnd\n\t\t};\n\t}\n\n\t/**\n\t * Puts everything together: merges the paths from/to the centre of the ports,\n\t * with the path calculated around other elements.\n\t */\n\tcalculateDynamicPath(\n\t\troutingMatrix: number[][],\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tpathToStart: number[][],\n\t\tpathToEnd: number[][]\n\t) {\n\t\t// generate the path based on the matrix with obstacles\n\t\tconst grid = new PF.Grid(routingMatrix);\n\t\tconst dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n\n\t\t// aggregate everything to have the calculated path ready for rendering\n\t\tconst pathCoords = pathToStart\n\t\t\t.concat(dynamicPath, pathToEnd)\n\t\t\t.map((coords) => [\n\t\t\t\tthis.factory.translateRoutingX(coords[0], true),\n\t\t\t\tthis.factory.translateRoutingY(coords[1], true)\n\t\t\t]);\n\t\treturn PF.Util.compressPath(pathCoords);\n\t}\n}\n","import * as React from 'react';\nimport { DiagramEngine, LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\nimport { DefaultLinkModel, DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\n\nexport interface RightAngleLinkProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: RightAngleLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: RightAngleLinkFactory;\n}\n\nexport interface RightAngleLinkState {\n\tselected: boolean;\n\tcanDrag: boolean;\n}\n\nexport class RightAngleLinkWidget extends React.Component<RightAngleLinkProps, RightAngleLinkState> {\n\tpublic static defaultProps: RightAngleLinkProps = {\n\t\tcolor: 'red',\n\t\twidth: 3,\n\t\tlink: null,\n\t\tsmooth: false,\n\t\tdiagramEngine: null,\n\t\tfactory: null\n\t};\n\n\trefPaths: React.RefObject<SVGPathElement>[];\n\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n\trefLabels: { [id: string]: HTMLElement };\n\tdragging_index: number;\n\n\tconstructor(props: RightAngleLinkProps) {\n\t\tsuper(props);\n\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false,\n\t\t\tcanDrag: false\n\t\t};\n\n\t\tthis.dragging_index = 0;\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={extraProps}\n\t\t\t/>\n\t\t);\n\t}\n\n\tcalculatePositions(points: PointModel[], event: MouseEvent, index: number, coordinate: string) {\n\t\t// If path is first or last add another point to keep node port on its position\n\t\tif (index === 0) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index].getX(), points[index].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index);\n\t\t\tthis.dragging_index++;\n\t\t\treturn;\n\t\t} else if (index === points.length - 2) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index + 1].getX(), points[index + 1].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index + 1);\n\t\t\treturn;\n\t\t}\n\n\t\t// Merge two points if it is not close to node port and close to each other\n\t\tif (index - 2 > 0) {\n\t\t\tlet _points = {\n\t\t\t\t[index - 2]: points[index - 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index - 1]: points[index - 1].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n\t\t\t\t_points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index - 2].setPosition(_points[index - 2]);\n\t\t\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tthis.dragging_index--;\n\t\t\t\tthis.dragging_index--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Merge two points if it is not close to node port\n\t\tif (index + 2 < points.length - 2) {\n\t\t\tlet _points = {\n\t\t\t\t[index + 3]: points[index + 3].getPosition(),\n\t\t\t\t[index + 2]: points[index + 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index]: points[index].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n\t\t\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index].setPosition(_points[index]);\n\t\t\t\tpoints[index + 3].setPosition(_points[index + 3]);\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If no condition above handled then just update path points position\n\t\tlet _points = {\n\t\t\t[index]: points[index].getPosition(),\n\t\t\t[index + 1]: points[index + 1].getPosition()\n\t\t};\n\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\tpoints[index].setPosition(_points[index]);\n\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t}\n\n\tdraggingEvent(event: MouseEvent, index: number) {\n\t\tlet points = this.props.link.getPoints();\n\t\t// get moving difference. Index + 1 will work because links indexes has\n\t\t// length = points.lenght - 1\n\t\tlet dx = Math.abs(points[index].getX() - points[index + 1].getX());\n\t\tlet dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n\t\t// moving with y direction\n\t\tif (dx === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'x');\n\t\t} else if (dy === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'y');\n\t\t}\n\t\tthis.props.link.setFirstAndLastPathsDirection();\n\t}\n\n\thandleMove = function (event: MouseEvent) {\n\t\tthis.draggingEvent(event, this.dragging_index);\n\t}.bind(this);\n\n\thandleUp = function (event: MouseEvent) {\n\t\t// Unregister handlers to avoid multiple event handlers for other links\n\t\tthis.setState({ canDrag: false, selected: false });\n\t\twindow.removeEventListener('mousemove', this.handleMove);\n\t\twindow.removeEventListener('mouseup', this.handleUp);\n\t}.bind(this);\n\n\trender() {\n\t\t//ensure id is present for all points on the path\n\t\tlet points = this.props.link.getPoints();\n\t\tlet paths = [];\n\n\t\t// Get points based on link orientation\n\t\tlet pointLeft = points[0];\n\t\tlet pointRight = points[points.length - 1];\n\t\tlet hadToSwitch = false;\n\t\tif (pointLeft.getX() > pointRight.getX()) {\n\t\t\tpointLeft = points[points.length - 1];\n\t\t\tpointRight = points[0];\n\t\t\thadToSwitch = true;\n\t\t}\n\t\tlet dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n\n\t\t// When new link add one middle point to get everywhere 90° angle\n\t\tif (this.props.link.getTargetPort() === null && points.length === 2) {\n\t\t\t[...Array(2)].forEach((item) => {\n\t\t\t\tthis.props.link.addPoint(\n\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t\t}),\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t});\n\t\t\tthis.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n\t\t}\n\t\t// When new link is moving and not connected to target port move with middle point\n\t\t// TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n\t\t//  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n\t\telse if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n\t\t\tpoints[1].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointLeft.getY() : pointRight.getY()\n\t\t\t);\n\t\t\tpoints[2].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointRight.getY() : pointLeft.getY()\n\t\t\t);\n\t\t}\n\t\t// Render was called but link is not moved but user.\n\t\t// Node is moved and in this case fix coordinates to get 90° angle.\n\t\t// For loop just for first and last path\n\t\telse if (!this.state.canDrag && points.length > 2) {\n\t\t\t// Those points and its position only will be moved\n\t\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\n\t\t\t\tif (i - 1 === 0) {\n\t\t\t\t\tif (this.props.link.getFirstPathXdirection()) {\n\t\t\t\t\t\tpoints[i].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.props.link.getLastPathXdirection()) {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If there is existing link which has two points add one\n\t\t// NOTE: It doesn't matter if check is for dy or dx\n\t\tif (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n\t\t\tthis.props.link.addPoint(\n\t\t\t\tnew PointModel({\n\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\tpaths.push(\n\t\t\t\tthis.generateLink(\n\t\t\t\t\tLinkWidget.generateLinePath(points[j], points[j + 1]),\n\t\t\t\t\t{\n\t\t\t\t\t\t'data-linkid': this.props.link.getID(),\n\t\t\t\t\t\t'data-point': j,\n\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\n\t\t\t\t\t\t\tif (event.button === 0) {\n\t\t\t\t\t\t\t\tthis.setState({ canDrag: true });\n\t\t\t\t\t\t\t\tthis.dragging_index = j;\n\t\t\t\t\t\t\t\t// Register mouse move event to track mouse position\n\t\t\t\t\t\t\t\t// On mouse up these events are unregistered check \"this.handleUp\"\n\t\t\t\t\t\t\t\twindow.addEventListener('mousemove', this.handleMove);\n\t\t\t\t\t\t\t\twindow.addEventListener('mouseup', this.handleUp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonMouseEnter: (event: MouseEvent) => {\n\t\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t\t\tthis.props.link.lastHoverIndexOfPath = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tj\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tthis.refPaths = [];\n\t\treturn <g data-default-link-test={this.props.link.getOptions().testName}>{paths}</g>;\n\t}\n}\n","module.exports = require(\"@projectstorm/react-diagrams-core\");","module.exports = require(\"@projectstorm/geometry\");","import * as React from 'react';\nimport { RightAngleLinkWidget } from './RightAngleLinkWidget';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { DefaultLinkFactory, DefaultLinkModel } from '@projectstorm/react-diagrams-defaults';\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\n\n/**\n * @author Daniel Lazar\n */\nexport class RightAngleLinkFactory extends DefaultLinkFactory<RightAngleLinkModel> {\n\tstatic NAME = 'rightAngle';\n\n\tconstructor() {\n\t\tsuper(RightAngleLinkFactory.NAME);\n\t}\n\n\tgenerateModel(event): RightAngleLinkModel {\n\t\treturn new RightAngleLinkModel();\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <RightAngleLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\n\t}\n}\n","import { DefaultLinkModel, DefaultLinkModelOptions } from '@projectstorm/react-diagrams-defaults';\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\nimport { DeserializeEvent } from '@projectstorm/react-canvas-core';\n\nexport class RightAngleLinkModel extends DefaultLinkModel {\n\tlastHoverIndexOfPath: number;\n\tprivate _lastPathXdirection: boolean;\n\tprivate _firstPathXdirection: boolean;\n\tconstructor(options: DefaultLinkModelOptions = {}) {\n\t\tsuper({\n\t\t\ttype: RightAngleLinkFactory.NAME,\n\t\t\t...options\n\t\t});\n\t\tthis.lastHoverIndexOfPath = 0;\n\t\tthis._lastPathXdirection = false;\n\t\tthis._firstPathXdirection = false;\n\t}\n\n\tsetFirstAndLastPathsDirection() {\n\t\tlet points = this.getPoints();\n\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\n\t\t\tlet dx = Math.abs(points[i].getX() - points[i - 1].getX());\n\t\t\tlet dy = Math.abs(points[i].getY() - points[i - 1].getY());\n\t\t\tif (i - 1 === 0) {\n\t\t\t\tthis._firstPathXdirection = dx > dy;\n\t\t\t} else {\n\t\t\t\tthis._lastPathXdirection = dx > dy;\n\t\t\t}\n\t\t}\n\t}\n\n\t// @ts-ignore\n\taddPoint<P extends PointModel>(pointModel: P, index: number = 1): P {\n\t\t// @ts-ignore\n\t\tsuper.addPoint(pointModel, index);\n\t\tthis.setFirstAndLastPathsDirection();\n\t\treturn pointModel;\n\t}\n\n\tdeserialize(event: DeserializeEvent<this>) {\n\t\tsuper.deserialize(event);\n\t\tthis.setFirstAndLastPathsDirection();\n\t}\n\n\tsetManuallyFirstAndLastPathsDirection(first, last) {\n\t\tthis._firstPathXdirection = first;\n\t\tthis._lastPathXdirection = last;\n\t}\n\n\tgetLastPathXdirection(): boolean {\n\t\treturn this._lastPathXdirection;\n\t}\n\tgetFirstPathXdirection(): boolean {\n\t\treturn this._firstPathXdirection;\n\t}\n\n\tsetWidth(width: number) {\n\t\tthis.options.width = width;\n\t\tthis.fireEvent({ width }, 'widthChanged');\n\t}\n\n\tsetColor(color: string) {\n\t\tthis.options.color = color;\n\t\tthis.fireEvent({ color }, 'colorChanged');\n\t}\n}\n","export * from './link/PathFindingLinkFactory';\nexport * from './link/PathFindingLinkModel';\nexport * from './link/PathFindingLinkWidget';\nexport * from './link/RightAngleLinkWidget';\nexport * from './link/RightAngleLinkFactory';\nexport * from './link/RightAngleLinkModel';\n\nexport * from './engine/PathFinding';\nexport * from './dagre/DagreEngine';\n","module.exports = require(\"pathfinding\");","module.exports = require(\"paths-js/path\");","module.exports = require(\"@projectstorm/react-canvas-core\");","import { DiagramModel, PointModel } from '@projectstorm/react-diagrams-core';\nimport * as dagre from 'dagre';\nimport * as _ from 'lodash';\nimport { GraphLabel } from 'dagre';\nimport { Point } from '@projectstorm/geometry';\n\nexport interface DagreEngineOptions {\n\tgraph?: GraphLabel;\n\t/**\n\t * Will also layout links\n\t */\n\tincludeLinks?: boolean;\n}\n\nexport class DagreEngine {\n\toptions: DagreEngineOptions;\n\n\tconstructor(options: DagreEngineOptions = {}) {\n\t\tthis.options = options;\n\t}\n\n\tredistribute(model: DiagramModel) {\n\t\t// Create a new directed graph\n\t\tvar g = new dagre.graphlib.Graph({\n\t\t\tmultigraph: true\n\t\t});\n\t\tg.setGraph(this.options.graph || {});\n\t\tg.setDefaultEdgeLabel(function () {\n\t\t\treturn {};\n\t\t});\n\n\t\tconst processedlinks: { [id: string]: boolean } = {};\n\n\t\t// set nodes\n\t\t_.forEach(model.getNodes(), (node) => {\n\t\t\tg.setNode(node.getID(), { width: node.width, height: node.height });\n\t\t});\n\n\t\t_.forEach(model.getLinks(), (link) => {\n\t\t\t// set edges\n\t\t\tif (link.getSourcePort() && link.getTargetPort()) {\n\t\t\t\tprocessedlinks[link.getID()] = true;\n\t\t\t\tg.setEdge({\n\t\t\t\t\tv: link.getSourcePort().getNode().getID(),\n\t\t\t\t\tw: link.getTargetPort().getNode().getID(),\n\t\t\t\t\tname: link.getID()\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// layout the graph\n\t\tdagre.layout(g);\n\n\t\tg.nodes().forEach((v) => {\n\t\t\tconst node = g.node(v);\n\t\t\tmodel.getNode(v).setPosition(node.x - node.width / 2, node.y - node.height / 2);\n\t\t});\n\n\t\t// also include links?\n\t\tif (this.options.includeLinks) {\n\t\t\tg.edges().forEach((e) => {\n\t\t\t\tconst edge = g.edge(e);\n\t\t\t\tconst link = model.getLink(e.name);\n\n\t\t\t\tconst points = [link.getFirstPoint()];\n\t\t\t\tfor (let i = 1; i < edge.points.length - 2; i++) {\n\t\t\t\t\tpoints.push(new PointModel({ link: link, position: new Point(edge.points[i].x, edge.points[i].y) }));\n\t\t\t\t}\n\t\t\t\tlink.setPoints(points.concat(link.getLastPoint()));\n\t\t\t});\n\t\t}\n\t}\n}\n","module.exports = require(\"dagre\");"],"sourceRoot":""}